## অবস্থা: একটি কম্পোনেন্টের মেমোরি

ইউজার ইন্টারঅ্যাকশনের জন্য মাঝে মধ্যে আমাদের এপ্লিকেশনের UI পরিবর্তন করে আপডেট করতে হবে। কোনো ইউজারের ক্রিয়াকলাপের ফলে স্ক্রিনে কিছু পরিবর্তন করতে হলে কম্পোনেন্টগুলিকে প্রায়ই তা মনে রাখতে হয়। যেমন, ফর্মে কিছু লিখলে ইনপুট ফিল্ড আপডেট হওয়া, ইমেজ ক্যারোসেলে "পরবর্তী" বাটনে ক্লিক করলে পরবর্তী ইমেজকে দেখানো, "কিনুন" বোতামে ক্লিক করলে শপিং কার্টে পণ্য যোগ করা ইত্যাদি। কম্পোনেন্টগুলিকে বর্তমান ইনপুট মান, বর্তমান ইমেজ, বর্তমানের শপিং কার্ট স্টেট ইত্যাদি মনে রাখতে হয়। রিঅ্যাক্টে এই ধরনের কম্পোনেন্ট-নির্দিষ্ট মেমোরিকে অবস্থা (state) বলা হয়।

আপনি শিখবেন

- useState হুক ব্যবহার করে কিভাবে একটি অবস্থা ভেরিয়েবল যোগ করতে হয়
- useState হুক কোন জোড়া মান রিটার্ন করে।
- একাধিক অবস্থা ভেরিয়েবল কিভাবে যোগ করতে হয়।
- অবস্থাকে স্থানীয় (local) কেন বলা হয়?

## যখন একটি রেগুলার ভেরিয়েবল যথেষ্ট নয়

এখানে একটি কম্পোনেন্ট রয়েছে যা একটি মূর্তির ছবি প্রদর্শন করে। "পরবর্তী" বাটনে ক্লিক করলে সূচকটি 1, তারপরে 2 ইত্যাদিতে পরিবর্তন করে পরবর্তী মূর্তি দেখানো উচিত। তবে, এটি কাজ করবে না (আপনি এটি চেষ্টা করে দেখতে পারেন!):

```javascript
import { sculptureList } from "./data.js";

export default function Gallery() {
  let index = 0;

  function handleClick() {
    index = index + 1;
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleClick}>পরবর্তী</button>
      <h2>
        <i>{sculpture.name} </i>
        বよって {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <img src={sculpture.url} alt={sculpture.alt} />
      <p>{sculpture.description}</p>
    </>
  );
}
```

handleClick ইভেন্ট হ্যান্ডলার একটি স্থানীয় ভেরিয়েবল, index আপডেট করছে। কিন্তু এই পরিবর্তনটি দৃশ্যমান হওয়াকে দুটি জিনিস বাধা দেয়:

- স্থানীয় ভেরিয়েবলগুলি রেন্ডারগুলির মধ্যে টিকে থাকে না। রিঅ্যাক্ট যখন এই কম্পোনেন্টটি দ্বিতীয়বার রেন্ডার করে, তখন এটি এটিকে স্ক্র্যাচ থেকে রেন্ডার করে—এটি স্থানীয় ভেরিয়েবলগুলিতে কোনো পরিবर्तন বিবেচনা করে না।
- স্থানীয় ভেরিয়েবলগুলিতে পরিবर्तনগুলি রেন্ডারগুলিকে ট্রিগার করবে না। রিঅ্যাক্ট জানে না যে নতুন ডেটা সহ কম্পোনেন্টটি আবার রেন্ডার করতে হবে।

নতুন ডেটা সহ একটি কম্পোনেন্ট আপডেট করতে, দুটি জিনিস ঘটতে হবে:

- রেন্ডারগুলির মধ্যে ডেটা ধরে রাখুন।
- নতুন ডেটা সহ কম্পোনেন্টটি রেন্ডার করতে রিঅ্যাক্টকে ট্রিগার করুন (পুনঃ-রেন্ডারিং)।

useState হুক সেই দুটি জিনিস সরবরাহ করে:

- রেন্ডারগুলির মধ্যে ডেটা ধরে রাখার জন্য একটি স্টেট ভেরিয়েবল।
- একটি স্টেট সেটার ফাংশন ভেরিয়েবলটি আপডেট করতে এবং রিঅ্যাক্টকে কম্পোনেন্টটি আবার রেন্ডার করতে ট্রিগার করতে।

## একটি স্টেট ভেরিয়েবল যোগ করা

একটি স্টেট ভেরিয়েবল যোগ করতে, ফাইলের শীর্ষে React থেকে useState ইমপোর্ট করুন:

```javascript
import { useState } from "react";
```

তারপরে, এই লাইনটি প্রতিস্থাপন করুন:

```javascript
let index = 0;
```

এই লাইনটি দিয়ে:

```javascript
const [index, setIndex] = useState(0);
```

index একটি স্টেট ভেরিয়েবল এবং setIndex হল সেটার ফাংশন।

এখানে [] সিনট্যাক্সকে array destructuring বলা হয় এবং এটি আপনাকে একটি অ্যারে থেকে মান পড়তে দেয়। useState দ্বারা ফেরত দেওয়া অ্যারেটিতে সর্বদা ঠিক দুটি আইটেম থাকে।

handleClick এ তারা কীভাবে একসাথে কাজ করে:

```javascript
function handleClick() {
  setIndex(index + 1);
}
```

এখন "পরবর্তী" বাটনে ক্লিক করলে বর্তমান মূর্তিটি পরিবর্তিত হয়:

```javascript
import { useState } from "react";
import { sculptureList } from "./data.js";

export default function Gallery() {
  const [index, setIndex] = useState(0);

  function handleClick() {
    setIndex(index + 1);
  }

  let sculpture = sculptureList[index];
  return <></>;
}
```

## আপনার প্রথম হুকের সাথে পরিচয় (Meet your first Hook)

রিঅ্যাক্টে, useState, সেইসাথে "use" দিয়ে শুরু হওয়া অন্য কোন ফাংশনকে হুক (Hook) বলা হয়।

হুকগুলি বিশেষ ফাংশন যা কেবল রিঅ্যাক্ট রেন্ডারিং করার সময়ই উপলব্ধ থাকে (যা আমরা পরের পৃষ্ঠায় আরও বিস্তারিতভাবে জানব)। আপনি এগুলির মাধ্যমে বিভিন্ন রিঅ্যাক্টের ফিচারগুলিতে "হুক" করতে পারেন।

স্টেট হ'ল সেই ফিচারগুলির মধ্যে কেবল একটি, তবে আপনি পরে অন্যান্য হুকগুলির সাথে পরিচিত হবেন।

## ফাঁদ (Pitfall)

_হুক (use দিয়ে শুরু হওয়া ফাংশনগুলি) কেবল আপনার কম্পোনেন্টগুলির শীর্ষ স্তরে বা আপনার নিজের হুকগুলিতে রুপান্তর করা যায়। আপনি শর্তাধীন, লুপ বা অন্যান্য একে অপরের মধ্যে থাকা ফাংশনগুলিতে হুক কল করতে পারবেন না।_

_হুকগুলি ফাংশন, তবে আপনার কম্পোনেন্টের প্রয়োজনীয়তা সম্পর্কে অনিঃশর্ত ঘোষণা হিসাবে এগুলি সম্পর্কে চিন্তা করা উপকারী। আপনি আপনার ফাইলের শীর্ষে "import" মডিউলগুলির মতো করে আপনার কম্পোনেন্টের শীর্ষে রিঅ্যাক্টের ফিচারগুলি "ব্যবহার" করেন।_

## useState এর গঠন (Anatomy of useState)

যখন আপনি useState কল করেন, আপনি রিঅ্যাক্টকে বলছেন যে আপনি চান এই কম্পোনেন্টটি কিছু মনে রাখুক:

```javascript
const [index, setIndex] = useState(0);
```

এই ক্ষেত্রে, আপনি চান রিঅ্যাক্ট index মনে রাখুক।

**নোট**

এই জোড়াকে const [something, setSomething] এর মতো নামকরণ করার রীতি আছে। আপনি এটিকে যেকোনো নাম দিতে পারেন, তবে রীতিগুলি প্রকল্প জুড়ে বোঝা সহজ করে।

useState এর একমাত্র আর্গুমেন্ট আপনার স্টেট ভেরিয়েবলের প্রাথমিক মান। এই উদাহরণে, index এর প্রাথমিক মান useState(0) দিয়ে 0 এ সেট করা হয়।

প্রতিবার আপনার কম্পোনেন্ট রেন্ডার হলে, useState আপনাকে দুটি মান সহ একটি অ্যারে দেয়:

- স্টেট ভেরিয়েবল (index) আপনি যে মানটি সংরক্ষণ করেছেন তার সাথে।
- স্টেট সেটার ফাংশন (setIndex) যা স্টেট ভেরিয়েবলটি আপডেট করতে পারে এবং রিঅ্যাক্টকে কম্পোনেন্টটি আবার রেন্ডার করতে ট্রিগার করতে পারে।

এটি কীভাবে কাজ করে তা এখানে:

```javascript
const [index, setIndex] = useState(0);
```

1. আপনার কম্পোনেন্ট প্রথমবার রেন্ডার হয়। যেহেতু আপনি index এর জন্য প্রাথমিক মান হিসাবে useState এ 0 পাস করেছেন, তাই এটি [0, setIndex] ফেরত পাঠাবে। রিঅ্যাক্ট মনে রাখে 0 সর্বশেষ স্টেট মান।

2. আপনি স্টেট আপডেট করেন। যখন কোন ব্যবহারকারী বাটনে ক্লিক করে, তখন এটি setIndex(index + 1) কল করে। index 0, তাই এটি setIndex(1)। এটি রিঅ্যাক্টকে মনে করিয়ে দেয় যে index এখন 1 এবং অন্য একটি রেন্ডার ট্রিগার করে।

3. আপনার কম্পোনেন্টের দ্বিতীয় রেন্ডার। রিঅ্যাক্ট এখনও useState(0) দেখে, কিন্তু যেহেতু রিঅ্যাক্ট মনে রাখে যে আপনি index কে 1 এ সেট করেছেন, তাই এটি [1, setIndex] ফেরত দেয়।

### একটি কম্পোনেন্টকে একাধিক স্টেট ভেরিয়েবল দেওয়া

আপনি আপনার কম্পোনেন্টে ইচ্ছেমত যত খুশি স্টেট ভেরিয়েবল যোগ করতে পারেন, এবং এগুলো যেকোন ধরনের হতে পারে। নিচের কম্পোনেন্টটিতে দুটি স্টেট ভেরিয়েবল রয়েছে: একটি সংখ্যা `index` এবং একটি বুলিয়ান `showMore`, যা আপনি "Show details" বাটনে ক্লিক করলে পরিবর্তিত হয়:

```javascript
import { useState } from "react";
import { sculptureList } from "./data.js";

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleNextClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? "Hide" : "Show"} details
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img src={sculpture.url} alt={sculpture.alt} />
    </>
  );
}
```

যদি স্টেটগুলো সম্পর্কিত না হয়, যেমন `index` এবং `showMore` এই উদাহরণে, তাহলে একাধিক স্টেট ভেরিয়েবল থাকা ভালো। তবে যদি আপনি দেখতে পান যে দুটি স্টেট ভেরিয়েবল একসাথে প্রায়ই পরিবর্তিত হয়, তাহলে এগুলোকে একত্রিত করে একটি বানানো সহজ হতে পারে। উদাহরণস্বরূপ, যদি আপনার একটি ফর্মে অনেকগুলো ফিল্ড থাকে, তাহলে প্রতিটি ফিল্ডের জন্য **আলাদা স্টেট ভেরিয়েবল না রেখে একটি অবজেক্ট ধরে রাখা সহজতর হয়**। স্টেট স্ট্রাকচার বাছাই করার আরও টিপস পেতে "Choosing the State Structure" পড়ুন।

## স্টেট বিচ্ছিন্ন এবং ব্যক্তিগত (State is isolated and private)

React-এ state isolated এবং private। এটি একটি component-এর instance-এ local থাকে। অর্থাৎ, যদি আপনি একই component দুবার render করেন, প্রতিটি কপির state সম্পূর্ণভাবে isolated থাকবে! একটির পরিবর্তন করলেও অন্যটিকে প্রভাবিত করবে না।

এই উদাহরণে, আগের Gallery component কোনো পরিবর্তন ছাড়াই দুবার render করা হয়েছে। প্রতিটি গ্যালারির বোতামগুলিতে ক্লিক করার চেষ্টা করুন। লক্ষ্য করুন যে তাদের state স্বাধীন:

```javascript
import Gallery from "./Gallery.js";

export default function Page() {
  return (
    <div className="Page">
      <Gallery />
      <Gallery />
    </div>
  );
}
```

এটি state-কে সাধারণ ভেরিয়েবল থেকে আলাদা করে। সাধারণ ভেরিয়েবলগুলো মডিউলের উপরে ঘোষিত হতে পারে, কিন্তু state কোনও নির্দিষ্ট ফাংশন কল বা কোডের নির্দিষ্ট জায়গার সাথে আবদ্ধ নয়, এটি "local" নির্দিষ্ট স্ক্রিনের জায়গার সাথে। আপনি দুইটি `<Gallery />` component render করেছেন, তাই তাদের state আলাদাভাবে সংরক্ষিত হয়েছে।

এছাড়াও লক্ষ্য করুন কিভাবে Page component Gallery-এর state সম্পর্কে কিছুই জানে না বা জানার প্রয়োজন নেই। props-এর মতো নয়, state সম্পূর্ণভাবে ঐ component-এর private। parent component এটি পরিবর্তন করতে পারে না। এটি আপনাকে যে কোনো component-এ state যোগ করতে বা সরাতে দেয় অন্য component-গুলোকে প্রভাবিত না করে।

যদি আপনি চান দুইটি গ্যালারি তাদের state synchronize রাখুক, তবে React-এ সঠিক উপায় হল child component থেকে state সরিয়ে তাদের নিকটতম shared parent-এ যোগ করা। পরবর্তী কয়েকটি পৃষ্ঠা একটি component-এর state সংগঠিত করার উপর কেন্দ্রিত হবে, তবে আমরা এই বিষয়টিতে ফিরব component-গুলির মধ্যে state ভাগাভাগি করার জন্য।

## রিক্যাপ (Recap)

1. **State ভেরিয়েবল ব্যবহার করুন:** যখন একটি component কে "মনে রাখতে" হবে কিছু তথ্য render-গুলোর মধ্যে, তখন state ভেরিয়েবল ব্যবহার করুন।

2. **State ভেরিয়েবল ঘোষণা করা হয় useState Hook ব্যবহার করে:** state ভেরিয়েবল ঘোষণা করার জন্য useState Hook কল করতে হয়।

3. **Hooks কী?** Hooks হল বিশেষ ফাংশন যেগুলো use দিয়ে শুরু হয়। এগুলো আপনাকে React-এর ফিচারগুলোর সাথে "hook into" করতে দেয়, যেমন state।

4. **Hooks এর শর্ত:** Hooks আমদানি (imports)-এর মতো মনে হতে পারে: এগুলো শর্তসাপেক্ষে কল করা যাবে না। useState সহ সমস্ত Hooks কেবল একটি component-এর উপরের স্তরে বা অন্য কোনো Hook-এর ভিতরে কল করা বৈধ।

5. **useState Hook কী ফেরত দেয়:** useState Hook দুটি মান ফেরত দেয়: বর্তমান state এবং এটি আপডেট করার ফাংশন।

6. **একাধিক state ভেরিয়েবল থাকতে পারে:** React অভ্যন্তরীণভাবে এগুলিকে তাদের ক্রম দ্বারা মিলিয়ে দেয়।

7. **State component-এর private:** যদি আপনি একটি component দুটি স্থানে render করেন, প্রতিটি কপি নিজস্ব state পাবে।
