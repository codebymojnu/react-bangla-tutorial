২ নাম্বার মডিউলে আমারা রিয়েক্ট এর ব্যাচ আপডেট নিয়ে দেখেছি এবং জেনেছি। আমরা জানি রিয়েক্টে যখন কোনো ফাংশন এর বডির ভিতরে অনেক গুলো স্টেট আপডেট হয় তখন রিয়েক্টে ওয়ান বাই ওয়ান স্টেট আপডেট না হয়ে একসাথে ব্যাচ আপডেট হয়ে। যেমনঃ

```jsx
const [number, setNumber] = useState(0);

const handleClidk = () => {
  setNumber(number + 1);
  setNumber(number + 1);
  setNumber(number + 1);
};

// result will be 1
```

আমরা জানি রিয়েক্ট এর ব্যাচ আপডেট এর কারনে উপরের স্টেট এর ভ্যালু `1` ই হবে। কারন নাম্বার এর ইনিশিয়াল ভ্যালু ০ ছিলো।

কিন্ত কি হবে যদি আমরা এসিঙ্ক্রোনাস ফাংশন ব্যাবহার করি এবং সেখানেও কি ব্যাচ আপডেট হবে?

যেমনঃ

```jsx
const [number, setNumber] = useState(0);

const handleClidk = async () => {
  setNumber(number + 1);
  await getSomeTime();
  setNumber(number + 5);
};
```

এখানে `number` এর ভ্যালু কত হতে পারে? এখানে `number` এর ভ্যালু `6` হবে ।

কারন `await` কোনো অ্যাসিঙ্ক্রোনাস অপারেশনকে **পজ (pause)** করে দেয়। অর্থাৎ, যখন আপনি `await` ব্যবহার করেন, তখন JavaScript বলে **_"এই ফাংশনটাকে এখানেই থামাও, বাকি অংশ পরবর্তীতে চালাও — যখন প্রমিস রিজলভ হবে।”_**
তাই রিয়েক্ট মনে করে , এখন নতুন একটা প্রসেস শুরু হয়েছে, তাই এর batching আগেরটার সঙ্গে মেশাবো না। সেই জন্য রিয়েক্টে `await` ব্যাবহার করার আগের স্টেটগুলোকে আপডেট করে দেয় এবং asyn ফাংশনটি রিসোল্ভ হয়ে আসলে পরবরতিতে আবার স্টেটকে আপডেট করে দেয়।

যেমন মডিউল ৩ এর একটা উদাহারণ দিয়ে দেখা যাকঃ

```jsx
async function handleSubmit(e) {
  e.preventDefault();
  setStatus("submitting"); // 1st update
  try {
    await submitForm(answer);
    setStatus("success");
  } catch (err) {
    setStatus("typing");
    setError(err);
  }
}
```

উপরের এই ফাংশনে `setStatus` দুইবার আপডেট করা হচ্ছে একবার `try/catch` ব্লোকে ঢুকার আগে আপডেট করবে এবং কোম্পোনেন্ট রি-রেন্ডার করবে, আরেকবার `try` এর ভিতর থেকে অথবা`catch` ব্লোক এর ভিতর থেকে স্টেট আপডেট হবে। এটা ডিপেন্ড করবে `submitForm` এই ফাংশন এর রেজাল্ট এর উপর।

ভুল ত্রুটি হলে ক্ষমা করবেন
